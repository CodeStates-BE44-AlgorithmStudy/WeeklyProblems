## 🤔Think

처음에는 BFS로 접근하려 했습니다. 최단 거리, 또는 최소 횟수 등을 찾는 알고리즘에서 BFS를 최대한 사용하려고 했거든요.

그런데 BFS로 접근을 하려고 보니, 서로 다른 단어를 선택했을 때, 서로 다른 결과가 나올 경우를 처리하기가 쉽지 않았습니다. 한 번 거쳤던 단어를 제거하는 방법도 여의치 않았고요.

그래서 DFS로 생각을 바꿔 접근했습니다. 아래는 문제 풀이 과정입니다.

## 🔎Solve

- `전체 단어의 목록`, `시작 단어`, `목표 단어`, `바뀐 횟수`, `바뀐 횟수를 담을 리스트`를 인자로 받는 재귀 함수(DFS)를 작성합니다.
- 단어 목록에서 바꿀 수 있는 단어(한 글자만 다른 단어)만 선택해 단어를 변경하고 해당 단어를 목록에서 지웁니다.
  - 해당 단어를 지우지 않으면,  A -> B -> A 의 무한 반복에 걸리게 됩니다.
- `단어의 목록`, `바뀐 단어`, `목표 단어`, `단어를 바꾼 횟수`, `바뀐 횟수를 담을 리스트`를 인자로 재귀에 들어갑니다.
- 만일 바뀐 단어가 목표 단어와 같으면 단어를 바꾼 횟수를 리스트에 담고 재귀를 벗어납니다.
- 만일 단어의 목록에 단어가 더 이상 남아있지 않다면 재귀를 벗어납니다.
- 전체 리스트에서 가장 적은 횟수를 Solution으로 반환합니다.
